{
  
    
        "post0": {
            "title": "DevOps Process",
            "content": "What is Continuous Integration: . Continuous integration (CI) is the practice of automating the integration of code changes from multiple contributors into a single software project. It’s a primary DevOps best practice, allowing developers to frequently merge code changes into a central repository where builds and tests then run. Automated tools are used to assert the new code’s correctness before integration. . A source code version control system is the crux of the CI process. The version control system is also supplemented with other checks like automated code quality tests, syntax style review tools, and more. . It allows for faster feedback, allows to fix bugs quickly, and so forth. . . What is Continuous Delivery: . A continuous delivery pipeline could have a manual gate right before production. A manual gate requires human intervention, and there could be scenarios in your organization that require manual gates in pipelines. Some manual gates might be questionable, whereas some could be legitimate. One legitimate scenario allows the business team to make a last-minute release decision. The engineering team keeps a shippable version of the product ready after every sprint, and the business team makes the final call to release the product to all customers, or a cross-section of the population, or perhaps to people who live in a certain geographical location. . Essentiallly, we want to make sure our work is going out to the internet, and is being deployed. It makes sure the programmer’s code is being delivered to multiple applications. . We can use any third pary softwares to deploy. The most common one is AWS. . . Proof of currently being deployed: . Most modern software development teams practice a pull request and code review workflow. Pull requests are a critical practice to effective CI. A pull request is created when a developer is ready to merge new code into the main codebase. The pull request notifies other developers of the new set of changes that are ready for integration. . Pull requests are an opportune time to kick off the CI pipeline and run the set of automated approval steps. An additional, manual approval step is commonly added at pull request time, during which a non-stakeholder engineer performs a code review of the feature. This allows for a fresh set of eyes to review the new code and functionality. The non-stakeholder will make edit suggestions and approve or deny the pull request. . Pull requests and code review are a powerful tool to foster passive communication and knowledge share among an engineering team. This helps guard against technical debt in the form of knowledge silos, where specific engineers are the only stakeholders for certain features of a code base. . We espeacially use GitHub to follow these functions. Pull requests let you tell others about changes you’ve pushed to a branch in a repository on GitHub. Once a pull request is opened, you can discuss and review the potential changes with collaborators and add follow-up commits before your changes are merged into the base branch. . Benefits of Pull Request Workflow . Clean git history - by using pull request, we can easily squash those redundant / unimportant / unclear commits before merging into main branch. | Remote code review process - before pull request, we did code review face to face either by pair programming or code presentation session. | Better software quality - making pull request means that the feature need to be approved by captain / lead and QA / QC. | . We haven’t used pull requests yet, however, we will be implementing them as we further develop our website. . GitHub Branches Strategies . Branches allow you to develop features, fix bugs, or safely experiment with new ideas in a contained area of your repository. You always create a branch from an existing branch. Typically, you might create a new branch from the default branch of your repository. You can then work on this new branch in isolation from changes that other people are making to the repository. . . Once we are done with the work, we can open a pull request to merge the changes in the current branch (the head branch) into another branch. . After a pull request has been merged, or closed, you can delete the head branch as this is no longer needed. You must have write access in the repository to delete branches. You can’t delete branches that are directly associated with open pull requests. . . Our Deployment Process . Software deployment plan To make sure the deployment process goes as smoothly as possible it is best to have a deployment plan that we follow. By having a plan you ensure that everything is done the same way each time changes are made. A deployment plan should include rules for when to deploy from local environments to development or staging sites as well as schedules for when new changes can go to a live environment. By having a set plan you reduce the risk of conflicts between different changes and make sure the deployment process is as smooth and easy as possible. If you’re working on an open-source project it also gives you the chance to do Release Candidates and let your community test it out for any bugs you might have missed yourself. Besides an overall plan, it’s also important to plan each individual change that you’re going to do. This process will be very quick for minor changes but should be much more extensive for big changes. By planning well in advance, you’re much better suited to have a smooth deployment process. . | The actual development Once you have the plan in place, it’s time to do the actual development. To ensure that any development can be done simultaneously and without breaking anything, it’s important to only work on local or development environments. . | Testing your changes Testing your changes is crucial to ensure that no bugs make it into the final production environment. But testing cannot be completed without deploying your changes to new environments. Once you’ve tested that all of your changes work on your local or development environment we deploy the changes to the next environment in line. This should be done all the way up to your staging environment, where final QA testing should be done. If everything is properly tested and works in an environment resembling your live environment it’s time to deploy it live. . | Deploying changes to the live environment Once all of the testing has been done on previous environments and any bugs have been fixed, it’s time to deploy your changes to the live environment. This should be a pretty safe thing to do, but everyone who’s worked with software development knows, that something can still go wrong. . | Monitor your changes Once your new changes are live and real users are actively using your website or application, it’s important to monitor that everything works as intended. No matter the planning put forward, there’s a chance that users encounter issues or perform actions that you did not anticipate during your planning and development. If we do need to roll back your changes, it’s important to keep calm and have a process to handle that as thoroughly as we handle deployments. . | . Clothing API . Here is how we are explaining the API: . Imagine you’re a customer at a restaurant. The waiter (the API) functions as an intermediary between customers like you (the user) and the kitchen (web server). You tell the waiter your order (API call), and the waiter requests it from the kitchen. Finally, the waiter will provide you with what you ordered. . . We mainly use RESTful APIs: . REST, or “representational state transfer,” is a type of software design that gives access to data (aka “web resources”) by using a uniform and predefined set of operations. The payload - the data to be delivered - defined in the request itself, will be formatted in a language such as HTML, JSON, or XML. The set of operations are the methods available to HTTP, which is the underlying protocol for how browsers retrieve websites from servers. These methods include GET, POST, PUT, DELETE, and others. . Obviously, our RESTful API gets and posts data from the internet through HTTP. This is explained in further detail by Bria. . .",
            "url": "https://b-g101.github.io/BASE/markdown/2022/10/22/devops.html",
            "relUrl": "/markdown/2022/10/22/devops.html",
            "date": " • Oct 22, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Project Wireframe",
            "content": "Project Idea . site revolving around online shopping and style guides it can have tools that help search | input favorite stores, and it will notify everytime there is new stock or when items on the wishlist are available | image search thing to find similar clothes using pixel finder | . | . Our Why: . help other teens their age find their style | fashion helps boosts people confidence when they wear what they want and feel good in it | We want to promote more positivitiy on campus through highlighting different styles | picked this idea because there could be a lot of database usage which will challenge us more than just frontend coding | We want to challenge ourselves by using more APIs and we think that this idea could include a lot of them | . . Wireframe . .",
            "url": "https://b-g101.github.io/BASE/markdown/2022/09/26/wireframes.html",
            "relUrl": "/markdown/2022/09/26/wireframes.html",
            "date": " • Sep 26, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Calculator Starters",
            "content": "| Overview | Calculator | Snake Game | . 0 1 2 3 + 4 5 6 - 7 8 9 * A/C 0 . / √ sin cos tan 3√ e^ =",
            "url": "https://b-g101.github.io/BASE/frontend/calculator",
            "relUrl": "/frontend/calculator",
            "date": " • Sep 5, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Regular Menu and GUI Menu",
            "content": "// imports allow you to use code already written by others. It is good to explore and learn libraries. The names around the dots often give you a hint to the originator of the code. import java.util.Scanner; //library for user input import java.lang.Math; //library for random numbers public class Menu { // Instance Variables public final String DEFAULT = &quot; u001B[0m&quot;; // Default Terminal Color public final String[][] COLORS = { // 2D Array of ANSI Terminal Colors {&quot;Default&quot;,DEFAULT}, {&quot;red&quot;, &quot; u001B[31m&quot;}, {&quot;green&quot;, &quot; u001B[32m&quot;}, {&quot;yellow&quot;, &quot; u001B[33m&quot;}, {&quot;blue&quot;, &quot; u001B[34m&quot;}, {&quot;purple&quot;, &quot; u001B[35m&quot;}, {&quot;cyan&quot;, &quot; u001B[36m&quot;}, {&quot;white&quot;, &quot; u001B[37m&quot;}, }; // 2D column location for data public final int NAME = 0; public final int ANSI = 1; // ANSI is the &quot;standard&quot; for terminal codes // Constructor on this Object takes control of menu events and actions public Menu() { Scanner sc = new Scanner(System.in); // using Java Scanner Object this.print(); // print Menu boolean quit = false; while (!quit) { try { // scan for Input int choice = sc.nextInt(); // using method from Java Scanner Object System.out.print(&quot;&quot; + choice + &quot;: &quot;); quit = this.action(choice); // take action } catch (Exception e) { sc.nextLine(); // error: clear buffer System.out.println(e + &quot;: Not a number, try again.&quot;); } } sc.close(); } // Print the menu options to Terminal private void print() { //System.out.println commands below is used to present a Menu to the user. System.out.println(&quot;- n&quot;); System.out.println(&quot;Choose from these choices&quot;); System.out.println(&quot;- n&quot;); System.out.println(&quot;1 - Say Hello&quot;); System.out.println(&quot;2 - color names&quot;); System.out.println(&quot;3 - aadya in different colors&quot;); System.out.println(&quot;0 - Quit&quot;); System.out.println(&quot;- n&quot;); } // Private method to perform action and return true if action is to quit/exit private boolean action(int selection) { boolean quit = false; switch (selection) { // Switch or Switch/Case is Control Flow statement and is used to evaluate the user selection case 0: System.out.print(&quot;bye!!&quot;); quit = true; break; case 1: System.out.print(&quot;hello!!!&quot;); break; case 2: for(int i = 0; i &lt; COLORS.length; i++) // loop through COLORS array System.out.print(COLORS[i][ANSI] + COLORS[i][NAME]); break; case 3: System.out.print(&quot;Loading...&quot;); for (int i = 0; i &lt; 20; i++) { // fixed length loading bar int random = (int) (Math.random() * COLORS.length); // random logic try { Thread.sleep(100); // delay for loading } catch (Exception e) { System.out.println(e); } System.out.print(COLORS[random][ANSI] + &quot;AADYA &quot;); } break; default: //Prints error message from console System.out.print(&quot;Unexpected choice, try again.&quot;); } System.out.println(DEFAULT); // make sure to reset color and provide new line return quit; } // Static driver/tester method static public void main(String[] args) { new Menu(); // starting Menu object } } Menu.main(null); . - Choose from these choices - 1 - Say Hello 2 - color names 3 - aadya in different colors 0 - Quit - 1: hello!!! 2: Defaultredgreenyellowbluepurplecyanwhite 3: Loading...AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA AADYA 4: Unexpected choice, try again. 0: bye!! . import java.awt.*; import java.awt.event.*; import javax.swing.*; import java.util.Timer; import java.util.TimerTask; // Graphical-User-Interface for Desktop in Java using Java Swing. public class MenuJFrame extends JFrame implements ActionListener { private JFrame frame; private JMenuBar menubar; private JMenu menu; private JLabel message = new JLabel(&quot;Click on Menu to select an action.&quot;); public final String[] MENUS = { // 1D Array of Menu Choices &quot;Hello&quot;, &quot;Colors&quot;, &quot;Loading bar&quot;, }; // Statics to assist with timer and messaging, single copy (no instance) private static int delay = 20; private static int step = 1; private static String hashes = &quot;&quot;; // Constructor enables the Frame instance, the object &quot;this.frame&quot; public MenuJFrame(String title) { // Initializing Key Objects frame = new JFrame(title); menubar = new JMenuBar(); menu = new JMenu(&quot;Menu&quot;); // Initializing Menu objects and adding actions for (String mx : MENUS) { JMenuItem m = new JMenuItem(mx); m.addActionListener(this); menu.add(m); } // Adding / Connecting Objects menubar.add(menu); frame.setJMenuBar(menubar); frame.add(message); // Sets JFrame close operation to Class variable JFrame.EXIT_ON_CLOSE frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // set the size of window based on objects frame.setSize(300,200); // makes the frame object visible according to properties previously set frame.setVisible(true); // flow of control shifts to frame object } // event from user selecting a menu option public void actionPerformed(ActionEvent e) { // local variable to ActinEvent String selection = e.getActionCommand(); // menu selection String msg; // local variable to create response from action final String[] COLORS = {&quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;}; // add more colors here final String start_msg = &quot;&lt;html&gt;&quot;; // html building final String end_msg = &quot;&lt;/html&gt;&quot;; final String hash = &quot;#&quot;; // run code based on the menuItem that was selected if ( selection.equals(MENUS[0]) ) { // Hello Action msg = &quot;Hello, World&quot;; message.setText(msg); } else if ( selection.equals(MENUS[1]) ) { // Color Action msg = start_msg + &quot;&lt;p&gt;&quot; + selection + &quot;&lt;/p&gt;&quot;; for (String color : COLORS) { msg += &quot;&lt;font color=&quot; + color + &quot;&gt;&quot; + color + &quot; &lt;/font&gt;&quot;; } msg += end_msg; message.setText(msg); } else { // Loading Bar Action String loading = &quot;&lt;p&gt;Loading&lt;/p&gt;&quot;; // Code to run on a Timer Timer timer = new Timer(); TimerTask task = new TimerTask() { public void run() { // Method for TimerTask // Static and Local variables used to manage message building int random = (int) (Math.random() * COLORS.length); // random logic MenuJFrame.hashes += &quot;&lt;font color=&quot; + COLORS[random] + &quot;&gt;&quot; + hash + &quot;&lt;/font&gt;&quot;; String msg = start_msg + loading + hashes + end_msg; message.setText(msg); // Shutdown timer and reset data if(MenuJFrame.step++ &gt; MenuJFrame.delay) { MenuJFrame.step = 1; MenuJFrame.hashes=&quot;&quot;; timer.cancel(); } }; }; // Schedule task and interval timer.schedule(task, 200, 200); message.setText(start_msg + loading + hash + end_msg); // prime/initial display } } // Driver turn over control the GUI public static void main(String[] args) { // Activates an instance of MenuJFrame class, which makes a JFrame object new MenuJFrame(&quot;Menu&quot;); } } MenuJFrame.main(null); . System.out.println(&quot;hi&quot;) //testing if cells after the GUI menu runs succesfully after loading the menu // executed with state Success . hi .",
            "url": "https://b-g101.github.io/BASE/2022/09/03/menus.html",
            "relUrl": "/2022/09/03/menus.html",
            "date": " • Sep 3, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Snake Game",
            "content": "| Overview | Calculator | Snake Game | . . Snake Game . Score: 0 New Game .",
            "url": "https://b-g101.github.io/BASE/frontend/snake_game",
            "relUrl": "/frontend/snake_game",
            "date": " • Sep 2, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://b-g101.github.io/BASE/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://b-g101.github.io/BASE/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "Frontend Hacks",
          "content": "| Overview | Calculator | Snake Game | . This is page where we can work on frontend pages like our Snake Game and the Math Class calculator. . Snake Game . Backend Language: Java | serve as an administrative UI for backend developers | snake game works on the Fastpages due to the GUI built | . Math Calculator . made using the Math class | there are different functions within the math class that produce different outputs | useful for us as we are in school and use calculators for many different things | unique interface with different types of math calculators | . More to Come! .",
          "url": "https://b-g101.github.io/BASE/frontend/overview",
          "relUrl": "/frontend/overview",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://b-g101.github.io/BASE/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}